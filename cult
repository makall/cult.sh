#!/usr/bin/env bash
#
#  CUrL Tester
#  A simple REST test framework for shell script.
#
# vim: ts=2 sw=2 sts=2 expandtab smartindent smarttab

set -o errexit -o nounset -o pipefail

: "${CULT_USER:=}"
: "${CULT_CLIENT:=}"
: "${CULT_WAIT:=}"
: "${CULT_STEP:=}"
: "${CULT_CASE:=}"
: "${CULT_SCENARIO:=}"

: "${CULT_ENV:=.cult}"

: "${CURRENT_STEP:=}"
: "${CURRENT_CASE:=}"
: "${CURRENT_SCENARIO:=}"
: "${CURRENT_RESPONSE:=}"
: "${CURRENT_CLIENT:=}"
: "${CURRENT_USER:=}"
: "${CURRENT_TOKEN:=}"
: "${CURRENT_TOKEN_EXPIRATION:=}"

: "${LOGOUT:=}"

declare -a REQUEST_PARAMS
declare -a QUERY_PARAMS
declare -a CULT_ASSERT
declare -a CULT_PRINT
declare -A CULT_VARIABLES
declare -A CURRENT_VARIABLES

CULT_FAIL=0

FAIL='\u2717'
WARN='\u25CF'
INFO='\u2714'
STEPS=('\u25cb' '\u25cf' '\u25cb' '\u25cc')

tint() {
	printf "\e[%d;1m%b\e[m" "$@"
	echo
}

logo() {
	tint 33 '    ___             __   _____          ' 0 '_'
	tint 33 "   / __\/\ /\\" 0 ' _ __ ' 33 "/ /  /__   \\" 0 '___  ___| |_ ___ _ __'
	tint 33 "  / /  / / \ \\" 0 " '__" 33 '/ /     / /\/' 0 " _ \/ __| __/ _ \ '__|"
	tint 33 ' / /___\ \_/ /' 0 ' | ' 33 '/ /___  / /' 0 ' |  __/\__ \ ||  __/ |'
	tint 33 ' \____/ \___/' 0 '|_| ' 33 '\____/  \/' 0 '   \___||___/\__\___|_|\n'
}

cleanup() {
	echo "CURRENT_BEGIN=$(date +%s)" > "$CULT_CACHE"
	echo -n > "$CULT_TRACE"
	echo -n > "$CULT_LOG"
}

setup() {
	exec > >(tee --append "$CULT_LOG")
	exec 2>&1
}

trace() {
	echo "$*" >&2
}

logger() {

	local POS
	local ICON
	local FOUND

	local CULT_ITEM="CULT_$1"
	local CURRENT_ITEM="CURRENT_$1"

	[ -n "${!CULT_ITEM}" ] && trace "[$1] ${!CULT_ITEM}"
	[ 0 -ne "$CULT_FAIL" ] && [ -n "${!CURRENT_ITEM}" ] && trace "[$1:FAILED] ${!CURRENT_ITEM}"

	if [ -n "${!CULT_ITEM}" ] && [ "${!CULT_ITEM}" != "${!CURRENT_ITEM}" ]; then
		tint 33 " ${STEPS[0]}" 0 " ${!CULT_ITEM}"
		declare -g 'CURRENT_ICON=0'
	fi

	if [ -n "${!CURRENT_ITEM}" ]; then

		QUERY="\e\[33;1m.*${!CURRENT_ITEM}\e\[m"
		FOUND=$(tac "$CULT_LOG" | grep -nP "$QUERY" | head -n 1 || true)

		if [ -n "$FOUND" ]; then

			POS=$(cut -d: -f1 <<< "$FOUND")

			if [ 0 -ne "$CULT_FAIL" ]; then
				ICON=$(tint 31 "$FAIL")
			elif [ -n "${CULT_FLUSH:-}" ]; then
				ICON=$(tint 32 "$INFO")
			elif [ -z "${!CULT_ITEM}" ] || [ "${!CULT_ITEM}" = "${!CURRENT_ITEM}" ]; then
				ICON=$(tint 33 "${STEPS[$((CURRENT_ICON % "${#STEPS[@]}"))]}")
			else
				ICON=$(tint 32 "$INFO")
			fi

			echo -ne "\e[s\e[${POS}A\r $ICON\e[u"
		fi
	fi

	if [ -n "${!CULT_ITEM}" ] && [ "${!CULT_ITEM}" != "${!CURRENT_ITEM}" ]; then
		declare -g "$CURRENT_ITEM=${!CULT_ITEM}"
	fi
}

request() {

	local JSON
	local STATUS

	local CURL=(curl --silent --verbose "$@")
	CURL+=(--write-out '%{http_code}' --output "$OUTPUT" --header "X-Cult-Trace-Id: $TRACE_ID")

	if [ -n "$CURRENT_TOKEN" ]; then
		CURL+=(--header "Authorization: Bearer $CURRENT_TOKEN")
	fi

	{
		echo -n "[REQUEST] ${CURL[0]}"
		printf " %q" "${CURL[@]:1}"
		echo
	} >&2

	while true; do
		STATUS=$("${CURL[@]}" || test -n "$CULT_WAIT")
		[ "$STATUS" != '000' ] && break
		sleep 1
		logger "STEP"
	done

	JSON=$(jq < "$OUTPUT" || jq --raw-input --slurp --ascii-output < "$OUTPUT")

	CURRENT_RESPONSE="{ \"status\": $STATUS, \"json\": ${JSON:-\"\"} }"
	trace "[RESPONSE] $CURRENT_RESPONSE"
}

auth_setup() {
	local CULT_ITEM="CULT_$1"
	local CURRENT_ITEM="CURRENT_$1"
	if [ -n "${!CULT_ITEM}" ] && [ "${!CULT_ITEM}" != "${!CURRENT_ITEM}" ]; then
		declare -g "$CURRENT_ITEM=${!CULT_ITEM}"
		CURRENT_TOKEN=''
	fi
}

throw() {
	tint 31 " $FAIL" 0 " $*"
	false
}

auth() {

	auth_setup 'USER'
	auth_setup 'CLIENT'

	if [ -n "$CURRENT_CLIENT" ]; then

		[ -n "${CLIENTS[$CURRENT_CLIENT]:-}" ] || throw "Client not defined: $CURRENT_CLIENT"

		if [ -z "$CURRENT_TOKEN" ] || [ "$(date '+%s')" -gt "${CURRENT_TOKEN_EXPIRATION:-0}" ]; then

			local DATA="grant_type=client_credentials"

			CURRENT_TOKEN=''

			if [ -n "$CURRENT_USER" ]; then
				[ -n "${USERS[$CURRENT_USER]:-}" ] || throw "User not defined: $CURRENT_USER"
				DATA="grant_type=password&username=$CURRENT_USER&password=${USERS[$CURRENT_USER]}"
			fi

			request "$TOKEN_ENDPOINT" \
				--header 'Content-Type: application/x-www-form-urlencoded' \
				--header "Authorization: Basic $(echo -n "$CURRENT_CLIENT:${CLIENTS[$CURRENT_CLIENT]}" | base64 --wrap=0)" \
				--data-raw "$DATA"

			query --exit-status ".status == 200" >&2

			CURRENT_TOKEN=$(query --exit-status --raw-output .json.access_token)
			CURRENT_TOKEN_EXPIRATION=$(query --exit-status --raw-output ".json.expires_in + $(date '+%s')")

		fi

	else
		CURRENT_TOKEN=''
	fi
}

count() {
	grep -cE "^[^:]+: \[$*\]" "$CULT_TRACE" || true
}

entry() {
	echo "$1 : $(count "$2") : $(count "$2:FAILED")"
}

report() {

	CULT_FAIL="$?"

	# Is the last script?
	if [ "$(ps -o stat= -p $$)" != "$(ps -o stat= -p $PPID)" ]; then

		exec 2> >(sed "s/^/${TRACE_ID}: /" >> "$CULT_TRACE")

		REQUESTS=$(count 'REQUEST')
		RESPONSES=$(count 'REQUEST')

		ASSERTIONS=$(count 'ASSERT')
		SUCCESSES=$(count 'INFO')

		FAILS=$((REQUESTS - RESPONSES + ASSERTIONS - SUCCESSES + $(count '[^:]+:FAILED')))

		# shellcheck disable=SC1090
		. "$CULT_CACHE"

		CULT_FAIL=$((CULT_FAIL + FAILS))
		CULT_FLUSH='1'

		CULT_STEP='' logger "STEP"
		CULT_CASE='' logger "CASE"
		CULT_SCENARIO='' logger "SCENARIO"

		tint 37 "\nReport\n"

		cat <<- EOF | column -ts: | sed 's/^/ /'
			Items : Executed : Failed
			$(entry "Scenarios" "SCENARIO")
			$(entry "Cases" "CASE")
			$(entry "Steps" "STEP")
			Requests : $REQUESTS : $((REQUESTS - RESPONSES))
			Assertions : $ASSERTIONS : $((ASSERTIONS - SUCCESSES))
		EOF

		[ -n "${CURRENT_BEGIN:-}" ] && echo -e "\n Total run duration: $(($(date '+%s') - CURRENT_BEGIN))s"

		tint 37 '\nResult\n'

		if [ 0 -eq "$((FAILS + CULT_FAIL))" ]; then
			tint 32 " $INFO SUCCEEDED\n"
		elif [ 0 -ne "$FAILS" ]; then
			tint 31 " $FAIL FAILED\n"
		else
			tint 33 " $WARN script existed with an error\n"
		fi

	fi

	return "$CULT_FAIL"
}

prepare_query_params() {
	for VARIABLE in "${!CURRENT_VARIABLES[@]}"; do
		QUERY_PARAMS+=(--arg "$VARIABLE" "${CURRENT_VARIABLES["$VARIABLE"]}")
	done
}

query() {
	jq "${QUERY_PARAMS[@]}" "$@" <<< "${CURRENT_RESPONSE:-{\}}"
}

assert_all() {
	for ASSERT in "${CULT_ASSERT[@]}"; do
		trace "[ASSERT] $ASSERT"
		query --exit-status "$ASSERT" >&2
		trace "[INFO] $ASSERT"
	done
}

extract_variables() {
	for VARIABLE in "${!CULT_VARIABLES[@]}"; do
		trace "[VARIABLE] $VARIABLE"
		CURRENT_VARIABLES["$VARIABLE"]=$(query --raw-output "${CULT_VARIABLES["$VARIABLE"]}" || echo null)
		trace "[VARIABLE] $VARIABLE=${CURRENT_VARIABLES["$VARIABLE"]}"
	done
}

substitute_request_params() {
	local VAR
	local VARS
	local PARAM

	VARS=$(printf "\$%s " "${!CURRENT_VARIABLES[@]}")

	for VAR in "${!CURRENT_VARIABLES[@]}"; do
		declare -x "$VAR=${CURRENT_VARIABLES[$VAR]}"
	done

	for PARAM in "$@"; do
		REQUEST_PARAMS+=("$(envsubst "${VARS[@]}" <<< "$PARAM")")
	done
}

print_all() {
	for PRINT in "${CULT_PRINT[@]}"; do
		trace "[PRINT] $PRINT"
		query --color-output "$PRINT"
	done
}

flush() {

	CULT_FAIL="$?"

	for CURRENT in $(set | sed -nE 's/^(CURRENT_[^=]*)=.*/\1/p'); do
		declare -p "$CURRENT"
	done > "$CULT_CACHE"

	return "$CULT_FAIL"
}

check_param() {
	[ 1 -lt "$#" ] && return
	throw "'$1' parameter value is expected"
}

while true; do
	case "${1:-}" in
		-w | --wait) CULT_WAIT="1" ;;
		--logout) LOGOUT="1" ;;
		-t | --test | -a | --assert)
			check_param "$@"
			CULT_ASSERT+=("$2")
			shift
			;;
		-e | --env)
			check_param "$@"
			CULT_ENV="$2"
			shift
			;;
		-p | --print)
			check_param "$@"
			CULT_PRINT+=("$2")
			shift
			;;
		-v | --var)
			check_param "$@"
			CULT_VARIABLES["$2"]="$3"
			shift 2
			;;
		-s | --step | --test-step)
			check_param "$@"
			CULT_STEP="           $2"
			shift
			;;
		-c | --case | --test-case)
			check_param "$@"
			CULT_CASE="     Case: $2"
			shift
			;;
		-S | --scenario | --test-scenario)
			check_param "$@"
			CULT_SCENARIO=" Scenario: $2"
			shift
			;;
		-u | --user)
			check_param "$@"
			CULT_USER="$2"
			shift
			;;
		-C | --client)
			check_param "$@"
			CULT_CLIENT="$2"
			shift
			;;
		--)
			shift
			break
			;;
		*) break ;;
	esac
	shift
done

CULT_TEMP_DIR="/tmp/cult"

mkdir -p "$CULT_TEMP_DIR"

CULT_LOG="$CULT_TEMP_DIR/log"
CULT_CACHE="$CULT_TEMP_DIR/cache"
CULT_EMPTY="$CULT_TEMP_DIR/empty"
CULT_TRACE="$CULT_TEMP_DIR/trace"

OUTPUT=$(mktemp)
TRACE_ID="${OUTPUT#*.}"

if [ "${BASH_SOURCE[0]}" != "$0" ]; then

	if [ 2 -eq "$SHLVL" ]; then
		cleanup
		setup
		logo
	fi

	trap 'report' EXIT
	return
fi

trap 'flush' EXIT
touch "$CULT_LOG"

# shellcheck disable=SC1090
[ -f "$CULT_CACHE" ] && . "$CULT_CACHE"

# shellcheck disable=SC1090
[ -f "$CULT_ENV" ] && . "$CULT_ENV"

if [ -n "$LOGOUT" ]; then
	CURRENT_CLIENT=''
	CURRENT_TOKEN=''
	CURRENT_USER=''
fi

exec 2> >(sed "s/^/${TRACE_ID}: /" >> "$CULT_TRACE")

CURRENT_ICON=$((1 + ${CURRENT_ICON:-0}))

logger "SCENARIO"
logger "CASE"
logger "STEP"

prepare_query_params

if [ 0 -lt "$#" ]; then

	auth

	if [ ! -t 0 ]; then
		echo '{}' > "$CULT_EMPTY"
		REQUEST_PARAMS+=(--header "Content-Type: application/json")
		REQUEST_PARAMS+=(--data-binary "$(jq "${QUERY_PARAMS[@]}" --from-file /dev/stdin "$CULT_EMPTY")")
	fi

	substitute_request_params "$@"

	request "${REQUEST_PARAMS[@]}"
fi

assert_all
extract_variables
print_all
