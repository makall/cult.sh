#!/usr/bin/env bash
#
#  CUrL Tester
#  A simple REST test framework for shell script.
#
# shellcheck disable=SC1090
# vim: ts=2 sw=2 sts=2 expandtab smartindent smarttab

set -o errexit -o nounset -o pipefail

: "${CULT_STEP:=}"
: "${CULT_CASE:=}"
: "${CULT_SCENARIO:=}"

: "${CULT_WAIT:=}"
: "${CULT_EXPECT:=2..}"

: "${CURRENT_STEP:=}"
: "${CURRENT_CASE:=}"
: "${CURRENT_SCENARIO:=}"

: "${CURRENT_STATUS:=}"
: "${CURRENT_RESPONSE:=}"

declare -a REQUEST_PARAMS
declare -a QUERY_PARAMS
declare -a CULT_ASSERT
declare -a CULT_PRINT
declare -A CULT_VARIABLES
declare -A CURRENT_VARIABLES

FAIL_ICON=$'\e[31;1m\u2717\e[m'
WARN_ICON=$'\e[33;1m\u25CF\e[m'
INFO_ICON=$'\e[32;1m\u2714\e[m'
STEP_ICONS=(
	$'\e[33;1m\u25cb\e[m'
	$'\e[33;1m\u25cf\e[m'
	$'\e[33;1m\u25cb\e[m'
	$'\e[33;1m\u25cc\e[m'
)

logo() {
	printf " \e[33;1m%s\e[m%s\e[33;1m%s\e[m%s\n" \
		"   ___        " "    " " __   _____ " "         _            " \
		"  / __\/\ /\\ " "_ __" " / /  /__   \\" "___  ___| |_ ___ _ __ " \
		" / /  / / \ \\" " '__" "/ /     / /\\/" " _ \/ __| __/ _ \ '__|" \
		"/ /___\ \_/ /" " |" " / /___  / /" " |  __/\__ \ ||  __/ |   " \
		"\____/ \___/" "|_|" " \____/  \/ " $'  \___||___/\__\___|_| \n'
}

cleanup() {
	echo "CURRENT_BEGIN=$(date +%s)" > "$CULT_CACHE"
	echo -n > "$CULT_TRACE"
	echo -n > "$CULT_LOG"
}

setup() {
	exec > >(tee --append "$CULT_LOG")
	exec 2>&1
}

logger() {

	local LOG_SIZE
	local FAILED="${2:-0}"
	local REPORT="${3:-0}"
	local CULT_ITEM="CULT_$1"
	local CURRENT_ITEM="CURRENT_$1"
	local CURRENT_ICON="CURRENT_$1_ICON"
	local CURRENT_LINE="CURRENT_$1_LINE"

	[ -n "${!CULT_ITEM}" ] && echo "[$1] ${!CULT_ITEM}" >&"$TRACE"
	[ 0 -ne "$FAILED" ] && [ -n "${!CURRENT_ITEM}" ] && echo "[$1:FAILED] ${!CURRENT_ITEM}" >&"$TRACE"

	if [ -n "${!CULT_ITEM}" ] && [ "${!CULT_ITEM}" != "${!CURRENT_ITEM}" ]; then
		echo -e " ${STEP_ICONS[0]} ${!CULT_ITEM}"
		declare -g "$CURRENT_ICON=1"
	fi

	LOG_SIZE=$(wc -l "$CULT_LOG" | cut -d ' ' -f1)

	if [ -n "${!CURRENT_ITEM}" ]; then

		local ICON="$INFO_ICON"
		local POS=$((1 + LOG_SIZE - ${!CURRENT_LINE}))

		if [ 0 -ne "$FAILED" ]; then
			ICON="$FAIL_ICON"
		elif [ 0 -ne "$REPORT" ]; then
			ICON="$INFO_ICON"
		elif [ -z "${!CULT_ITEM}" ] || [ "${!CULT_ITEM}" = "${!CURRENT_ITEM}" ]; then
			ICON="${STEP_ICONS[$((${!CURRENT_ICON} % "${#STEP_ICONS[@]}"))]}"
			declare -g "$CURRENT_ICON=$((1 + ${!CURRENT_ICON}))"
		fi

		echo -ne "\e[s\e[${POS}A\r $ICON\e[u"
	fi

	if [ 0 -ne "$FAILED" ] || [ -n "${!CULT_ITEM}" ] && [ "${!CULT_ITEM}" != "${!CURRENT_ITEM}" ]; then
		declare -g "$CURRENT_LINE=$LOG_SIZE"
		declare -g "$CURRENT_ITEM=${!CULT_ITEM}"
	fi
}

request() {

	local STATUS
	local CURL=(curl --silent --verbose --write-out '%{http_code}' --output "$OUTPUT" "$@")

	{
		echo -n "[REQUEST] ${CURL[0]}"
		printf " %q" "${CURL[@]:1}"
		echo
	} >&"$TRACE"

	while true; do
		STATUS=$("${CURL[@]}" 2>&"$TRACE" || test -n "$CULT_WAIT")
		[ "$STATUS" != '000' ] && break
		sleep 1
		logger "STEP"
	done

	CURRENT_STATUS="$STATUS"
	CURRENT_RESPONSE="$(< "$OUTPUT")"

	echo "[RESPONSE] $CURRENT_RESPONSE" >&"$TRACE"
}

throw() {
	echo -e " $FAIL_ICON $*" >&2
	return 1
}

count() {
	grep -cE "^[^:]+: \[$*\]" "$CULT_TRACE" || true
}

entry() {
	echo "$1 : $(count "$2") : $(count "$2:FAILED")"
}

title() {
	echo -e "\n\e[37;1m${*}\e[m\n"
}

report() {

	local FAILED="$?"

	REQUESTS=$(count 'REQUEST')
	RESPONSES=$(count 'REQUEST')

	ASSERTIONS=$(count 'ASSERT')
	SUCCESSES=$(count 'INFO')

	FAILS=$((REQUESTS - RESPONSES + ASSERTIONS - SUCCESSES + $(count '[^:]+:FAILED')))

	. "$CULT_CACHE"

	flush '0' '1' || true

	# Show report only at the end of the root script
	if [ "$(ps -o stat= -p $$)" != "$(ps -o stat= -p $PPID)" ]; then

		title 'Report'

		column -ts: <<- EOF | sed 's/^/ /'
			Items : Executed : Failed
			$(entry "Scenarios" "SCENARIO")
			$(entry "Cases" "CASE")
			$(entry "Steps" "STEP")
			Requests : $REQUESTS : $((REQUESTS - RESPONSES))
			Assertions : $ASSERTIONS : $((ASSERTIONS - SUCCESSES))
		EOF

		[ -n "${CURRENT_BEGIN:-}" ] && echo -e "\n Total run duration: $(($(date '+%s') - CURRENT_BEGIN))s"

		title 'Result'

		if [ 0 -ne "$FAILS" ]; then
			echo -e " $FAIL_ICON FAILED\n"
		elif [ 0 -ne "$FAILED" ]; then
			echo -e " $WARN_ICON Script existed with an error\n"
		else
			echo -e " $INFO_ICON SUCCEEDED\n"
		fi

	fi

	return "$FAILED"
}

prepare_query_params() {
	for VARIABLE in "${!CURRENT_VARIABLES[@]}"; do
		QUERY_PARAMS+=(--arg "$VARIABLE" "${CURRENT_VARIABLES["$VARIABLE"]}")
	done
}

fail() {
	{
		title "Status \`${CURRENT_STATUS:-???}\`"
		echo -e "${CURRENT_RESPONSE:-<EMPTY>}\n"
	} >&2
	throw "$@"
}

query() {
	local PARAMS=("${QUERY_PARAMS[@]}" "$@")
	if ! jq "${PARAMS[@]}" <<< "${CURRENT_RESPONSE:-{\}}"; then
		fail "Query failed: ${PARAMS[*]}\n"
	fi
}

assert_all() {
	for ASSERT in "${CULT_ASSERT[@]}"; do
		echo "[ASSERT] $ASSERT" >&"$TRACE"
		query --exit-status "$ASSERT" >&"$TRACE"
		echo "[INFO] $ASSERT" >&"$TRACE"
	done
}

extract_variables() {
	for VARIABLE in "${!CULT_VARIABLES[@]}"; do
		CURRENT_VARIABLES["$VARIABLE"]=$(query --raw-output "${CULT_VARIABLES["$VARIABLE"]}")
	done
}

substitute_request_params() {
	local VAR
	local VARS
	local PARAM

	VARS=$(printf "\$%s " "${!CURRENT_VARIABLES[@]}")

	for VAR in "${!CURRENT_VARIABLES[@]}"; do
		declare -x "$VAR=${CURRENT_VARIABLES[$VAR]}"
	done

	for PARAM in "$@"; do
		REQUEST_PARAMS+=("$(envsubst "${VARS[@]}" <<< "$PARAM")")
	done
}

print_all() {
	for PRINT in "${CULT_PRINT[@]}"; do
		title "Response \`$PRINT\`"
		query --color-output "$PRINT"
		echo
	done | sed 's/^/    /'
}

flush() {

	local FAILED="${1:-$?}"
	local REPORT="${2:-0}"

	if [ 0 -ne "$FAILED" ] || [ 0 -ne "$REPORT" ]; then
		CULT_SCENARIO='' logger "SCENARIO" "$FAILED" "$REPORT"
		CULT_CASE='' logger "CASE" "$FAILED" "$REPORT"
		CULT_STEP='' logger "STEP" "$FAILED" "$REPORT"
	fi

	for CURRENT in $(set | sed -nE 's/^(CURRENT_[^=]*)=.*/\1/p'); do
		declare -p "$CURRENT"
	done > "$CULT_CACHE"

	return "$FAILED"
}

check_param() {
	[ 1 -lt "$#" ] && return
	throw "'$1' parameter value is expected"
}

while true; do
	case "${1:-}" in
		-w | --wait) CULT_WAIT="1" ;;
		-t | --test | -a | --assert)
			check_param "$@"
			CULT_ASSERT+=("$2")
			shift
			;;
		-e | --expect)
			check_param "$@"
			CULT_EXPECT="$2"
			shift
			;;
		-p | --print)
			check_param "$@"
			CULT_PRINT+=("$2")
			shift
			;;
		-v | --var)
			check_param "$@"
			CULT_VARIABLES["$2"]="$3"
			shift 2
			;;
		-s | --step | --test-step)
			check_param "$@"
			CULT_STEP="           $2"
			shift
			;;
		-c | --case | --test-case)
			check_param "$@"
			CULT_CASE="     Case: $2"
			shift
			;;
		-S | --scenario | --test-scenario)
			check_param "$@"
			CULT_SCENARIO=" Scenario: $2"
			shift
			;;
		--)
			shift
			break
			;;
		*) break ;;
	esac
	shift
done

CULT_TEMP_DIR="/tmp/cult"

mkdir -p "$CULT_TEMP_DIR"

CULT_LOG="$CULT_TEMP_DIR/log"
CULT_CACHE="$CULT_TEMP_DIR/cache"
CULT_EMPTY="$CULT_TEMP_DIR/empty"
CULT_TRACE="$CULT_TEMP_DIR/trace"

OUTPUT=$(mktemp)
TRACE_ID="${OUTPUT#*.}"
exec {TRACE}> >(sed "s/^/${TRACE_ID}: /" >> "$CULT_TRACE")

touch "$CULT_LOG"

if [ "${BASH_SOURCE[0]}" != "$0" ]; then

	if [ 2 -eq "$SHLVL" ]; then
		cleanup
		setup
		logo
	fi

	trap 'report' EXIT
	return
fi

trap 'flush' EXIT

[ -f "$CULT_CACHE" ] && . "$CULT_CACHE"

logger "SCENARIO"
logger "CASE"
logger "STEP"

prepare_query_params

if [ 0 -lt "$#" ]; then

	if [ ! -t 0 ]; then
		echo '{}' > "$CULT_EMPTY"
		REQUEST_PARAMS+=(--header "Content-Type: application/json")
		REQUEST_PARAMS+=(--data-binary "$(jq "${QUERY_PARAMS[@]}" --from-file /dev/stdin "$CULT_EMPTY")")
	fi

	substitute_request_params "$@"

	request "${REQUEST_PARAMS[@]}"

	grep -qE "$CULT_EXPECT" <<< "$CURRENT_STATUS" || fail "Status differs from expected [$CULT_EXPECT]."
fi

assert_all
extract_variables
print_all
